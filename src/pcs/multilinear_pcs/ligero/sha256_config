use std::marker::PhantomData;

use ark_crypto_primitives::{
    crh::{CRHScheme, TwoToOneCRHScheme},
    sponge::Absorb
};
use ark_ff::PrimeField;
use sha2::Sha256;
use ark_crypto_primitives::sponge::CryptographicSponge;

pub struct Sha256Sponge {
    buffer: Vec<u8>,
    squeeze_counter: u64,
}

impl Sha256Sponge {
    pub fn new() -> Self {
        Self {
            buffer: Vec::new(),
            squeeze_counter: 0,
        }
    }
}

impl CryptographicSponge for Sha256Sponge {
    fn new() -> Self {
        Sha256Sponge::new()
    }

    fn absorb(&mut self, input: &[u8]) {
        self.buffer.extend_from_slice(input);
    }

    fn squeeze_bytes(&mut self, num_bytes: usize) -> Vec<u8> {
        let mut output = Vec::new();
        while output.len() < num_bytes {
            let mut hasher = Sha256::new();
            hasher.update(&self.buffer);
            hasher.update(self.squeeze_counter.to_le_bytes());
            output.extend_from_slice(&hasher.finalize());
            self.squeeze_counter += 1;
        }
        output.truncate(num_bytes);
        output
    }

    fn squeeze_field_elements<F: PrimeField>(&mut self, num_elements: usize) -> Vec<F> {
        let bytes = self.squeeze_bytes(num_elements * 32);
        bytes.chunks(32)
            .map(|chunk| F::from_be_bytes_mod_order(chunk))
            .collect()
    }

    fn reset(&mut self) {
        self.buffer.clear();
        self.squeeze_counter = 0;
    }
}

pub struct Sha256Hasher<F: PrimeField> {
    _field_data: PhantomData<F>,
}

impl<F: PrimeField + Absorb> CRHScheme for Sha256Hasher<F> {
    type Input = Vec<u8>;
    type Output = Vec<u8>;
    
    type Parameters = ();
    
    fn setup<R: ark_std::rand::Rng>(_r: &mut R) -> Result<Self::Parameters, ark_crypto_primitives::Error> {
        Ok(())
    }
    
    fn evaluate<T: std::borrow::Borrow<Self::Input>>(
        _parameters: &Self::Parameters,
        input: T,
    ) -> Result<Self::Output, ark_crypto_primitives::Error> {
        let mut hasher = Sha256::new();
        hasher.update(input.borrow());
        let res = hasher.finalize();
        Ok(res)
    }
}

pub struct Sha256TwoToOneHasher<F: PrimeField> {
    _field_data: PhantomData<F>,
}

impl<F: PrimeField + Absorb> TwoToOneCRHScheme for Sha256TwoToOneHasher<F> {
    type Input = Vec<u8>;
    type Output = Vec<u8>;
    
    type Parameters = ();
    
    fn setup<R: ark_std::rand::Rng>(_r: &mut R) -> Result<Self::Parameters, ark_crypto_primitives::Error> {
        Ok(())
    }
    
    fn evaluate<T: Borrow<Self::Input>>(
        parameters: &Self::Parameters,
        left_input: T,
        right_input: T,
    ) -> Result<Self::Output, ark_crypto_primitives::Error> {
        Self::compress(parameters, left_input, right_input)
    }
    
    fn compress<T: std::borrow::Borrow<Self::Output>>(
        _parameters: &Self::Parameters,
        left_input: T,
        right_input: T,
    ) -> Result<Self::Output, ark_crypto_primitives::Error> {
        let mut hasher = Sha256::new();
        hasher.update(left_input.borrow());
        hasher.update(right_input.borrow());
        let res = hasher.finalize();
        Ok(res.to_vec())
    }
}

pub struct Sha256FieldsToBytesHasher<F: PrimeField> {
    _field_data: PhantomData<F>,
}

impl<F: PrimeField + Absorb> CRHScheme for Sha256FieldsToBytesHasher<F>  {
    type Input = Vec<F>;
    type Output = Vec<u8>;
    type Parameters = ();

    fn setup<R: ark_std::rand::Rng>(_r: &mut R) -> Result<Self::Parameters, ark_crypto_primitives::Error> {
        Ok(())
    }

    fn evaluate<T: Borrow<Self::Input>>(
        _parameters: &Self::Parameters,
        input: T,
    ) -> Result<Self::Output, ark_crypto_primitives::Error> {
        let mut hasher = Sha256::new();
        hasher.update(input.borrow());
        let hash = hasher.finalize();
        Ok(hash.to_vec())
    }
}
